<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=1024, initial-scale=1.0">
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-chart-treemap"></script>
    <script src="https://cdn.jsdelivr.net/npm/axios/dist/axios.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-datalabels"></script>
    <script src="https://www.gstatic.com/firebasejs/8.10.0/firebase-app.js"></script>
    <script src="https://www.gstatic.com/firebasejs/8.10.0/firebase-database.js"></script>
    <link href="https://cdn.jsdelivr.net/npm/tailwindcss@2.2.19/dist/tailwind.min.css" rel="stylesheet">
    <style>
        .tab-container {
            display: flex;
            border-bottom: 2px solid #ccc;
        }
        .tab {
            padding: 10px 20px;
            cursor: pointer;
            border: 1px solid #ccc;
            border-bottom: none;
            background-color: #f9f9f9;
        }
        .tab.active {
            background-color: #fff;
            font-weight: bold;
            border-top: 2px solid #007BFF;
        }
        .chart-container {
            display: none;
        }
        .chart-container.active {
            display: block;
        }
    </style>
</head>
<body>
    <div style="width: 80%; margin: auto;">
        <!-- Accordion Tabs -->
        <div class="space-y-2">
            <!-- Tab 1 -->
            <div class="border rounded shadow">
                <button class="w-full text-left px-4 py-2 font-bold bg-gray-100 hover:bg-gray-200 focus:outline-none" onclick="toggleAccordion('chart1Content')">
                    차트 1: 회사별 자금 배분 비율 및 목표 보유 갯수
                </button>
                <div id="chart1Content" class="px-4 py-2">
                    <div class="tab-container">
                        <div class="tab active" onclick="showTab('chart1Now')">현재차트</div>
                        <div class="tab" onclick="showTab('chart1After')">수정후 차트</div>
                    </div>
                
                    <div id="chart1Now" class="chart-container active">
                        <canvas id="myChart1_now" width="400" height="200"></canvas>
                    </div>
                    <div id="chart1After" class="chart-container">
                        <canvas id="myChart1_after" width="400" height="200"></canvas>
                    </div>
                    <div id="trade" class="flex flex-wrap gap-4 justify-center p-4"></div>
                    <div> 수정 전 포트폴리오 지난 1개월 수익률 : <span id="performanceRate"></span>% 수익금액: <span id="performanceValue"></span></span></div>
                    <div> 수정 후 포트폴리오 지난 1개월 수익률 : <span id="performanceRateN"></span>% 수익금액: <span id="performanceValueN"></span></span></div>
                    <div>추가 투자금 : <span id="addingSeed"></span></div>
                    <div>총 평가금 : <span id="totalSeed"></span></div></br></br>
                    <span>종목별 목표주가 : <span id="targetPrice"></span></span>
                </div>
            </div>
             <!-- Tab 2 -->
            <div class="border rounded shadow">   
                <button class="w-full text-left px-4 py-2 font-bold bg-gray-100 hover:bg-gray-200 focus:outline-none" onclick="toggleAccordion('chart2Content')">
                    차트 2: 목표달성률 트래킹 및 인플레이션 감안 목표선
                </button>
                <div id="chart2Content" class="hidden px-4 py-2">
                    <canvas id="myChart2" width="400" height="200"></canvas>
                    <p><span>목표달성률 : <span id="goalAchievementRate"></span>%</span></p>
                    <p><span>기준값 대비 "<span id="goalOverPerformRate"></span>%" 초과달성 상황입니다.</span></p>
                    <label for="startDate">조회 시작 날짜:</label>
                    <input type="month" id="startDate" value="2024-01">
                    <label for="endDate">조회 종료 날짜:</label>
                    <input type="month" id="endDate" value="2040-12">
                    <button onclick="updateChart()">조회</button>
                </div>
            </div>
        </div>
    </div>
    
    <script>


        const firebaseConfig = {
            apiKey: "AIzaSyD2HEzJ5KRWYKH_rje4h5SSIzYb3ioR53Y",
            authDomain: "mydatabase-292f5.firebaseapp.com",
            databaseURL: "https://mydatabase-292f5-default-rtdb.firebaseio.com",
            projectId: "mydatabase-292f5",
            storageBucket: "mydatabase-292f5.firebasestorage.app",
            messagingSenderId: "649767823511",
            appId: "1:649767823511:web:27bc8a09a81dafb04021d2"
        };

        // Initialize Firebase
        firebase.initializeApp(firebaseConfig);
        const db = firebase.database();
        const dbRoot = firebase.database().ref('financeApp');
        function insertData(path, data) {
            let pathRef = dbRoot.child(path);
            pathRef.set(data)
            .then(() => {
                console.log("Data inserted successfully.");
            })
            .catch((error) => {
                console.error("Error inserting data: ", error);
            });
        }
        function updateData(path, data) {
            let pathRef = dbRoot.child(path);
            pathRef.update(data)
            .then(() => {
                console.log("Data updated successfully.");
            })
            .catch((error) => {
                console.error("Error removing data: ", error);
            });
        }
        function removeData(path) {
            let pathRef = dbRoot.child(path);
            pathRef.remove()
            .then(() => {
                console.log("Data removed successfully.");
            })
            .catch((error) => {
                console.error("Error removing data: ", error);
            });
        }
        function retrieveData(path) {
            return new Promise((resolve, reject) => {
                let pathRef = dbRoot.child(path); // Firebase 경로 참조
                pathRef.once('value', (snapshot) => {
                    const data = snapshot.val();
                    if (data) {
                        resolve(data); // 데이터를 Promise로 반환
                    } else {
                        console.log(`No data found at ${path}.`);
                        resolve(null); // 데이터가 없을 경우 null 반환
                    }
                }, (error) => {
                    console.error(`Error retrieving data from ${path}:`, error);
                    reject(error); // 에러를 Promise로 반환
                });
            });
        }

        async function preQuery() {
            try {
                // 여러 쿼리를 실행하고 결과를 기다림
                moneyCurveDatas = Object.values(await retrieveData('moneyCurveDatas'));
                apikeyList = await retrieveData('apikeyList');
                stocks = await retrieveData('targetPort');
                const userStocks = await retrieveData('userDatas');
                //유저정보 체크
                let userStock = [];
                while(userStock.length == 0){
                    let userName = prompt('이름을 입력하세요', 'cho');
                    userStock = userStocks.filter((data)=> data.name == userName)
                    if(userStock.length == 0){
                        alert('해당하는 이름이 등록되어있지않습니다.')
                    }
                }
                userStock = userStock[0].currentPort;
                // 1. array2를 ticker를 키로 하는 객체로 변환
                const map = userStock.reduce((acc, item) => {
                    acc[item.ticker] = item;
                    return acc;
                }, {});
                // const map = stocks.reduce((acc, item) => {
                //     acc[item.ticker] = item;
                //     return acc;
                // }, {});
                while (true) {
                    userInput = prompt('추가할 시드가 있나요? (krw)', 0);
                    if (!isNaN(userInput) && userInput.trim() !== "") {  // 숫자인지 확인
                        addingSeed = Number(userInput);
                        break;
                    } else {
                        alert("잘못된 입력입니다. 숫자만 입력해주세요.");
                    }
                }
                totalSeed += addingSeed;
                // 2. array1의 각 객체에 대해 동일한 ticker를 가진 array2의 정보를 병합
                const mergedArray = stocks.map(item => {
                    if (map[item.ticker]) {
                        return { ...item, ...map[item.ticker] };
                    }
                    return { ...item, count:0};
                });
                stocks = mergedArray;
                // 모든 쿼리가 완료된 후 init 실행
                init();
            } catch (error) {
                console.error("Error during queries:", error);
            }
        }


        let addingSeed = 0;
        let totalSeedBefore = 0; // 새로운 포폴에서 제거되는종목의 판매후 가격합계
        let totalSeed = addingSeed; 
        let dataset = [];
        let dataset2 = []; 
        let moneyCurveDatas;
        let apikeyList
        let currentKeyindex = 0;
        var myChart2;
        let stocks;
        function toggleAccordion(contentId) {
            const content = document.getElementById(contentId);
            const allContents = document.querySelectorAll('[id$="Content"]');

            allContents.forEach(c => {
                if (c !== content) c.classList.add('hidden');
            });

            content.classList.toggle('hidden');
        }
        function showTab(chartId){
            document.querySelectorAll('.tab').forEach(tab => tab.classList.remove('active'));
            document.querySelectorAll('.chart-container').forEach(container => container.classList.remove('active'));

            // Add active class to the selected tab and container
            document.querySelector(`[onclick="showTab('${chartId}')"]`).classList.add('active');
            document.getElementById(chartId).classList.add('active');
        }
        async function fetchStockData(stocks) {
            const baseUrl = "https://yfapi.net/v6/finance/quote";
            const sparkUrl = "https://yfapi.net/v8/finance/spark";
            const availableKeys = [...apikeyList];
            let currentIndex = 0;

            function getNextApiKey() {
                if (availableKeys.length === 0) {
                    console.log("모든 API 키가 제한에 도달했습니다.");
                    throw new Error("모든 API 키가 제한에 도달했습니다.");
                }
                currentIndex = (currentIndex) % apikeyList.length;
                return apikeyList[currentIndex];
            }

            async function fetchBatch(symbols) {
                let success = false;
                while (!success) {
                    const apiKey = getNextApiKey();
                    const baseOptions = {
                        method: 'GET',
                        url: baseUrl,
                        params: { symbols: symbols.join(","), region: 'US' },
                        headers: {
                            'x-api-key': apiKey
                        }
                    };

                    try {
                        const response = await axios.request(baseOptions);
                        return response.data.quoteResponse.result;
                    } catch (error) {
                        availableKeys.splice(currentIndex, 1);
                    }
                }
            }

            async function fetchBatchSpark(symbols) {
                let success = false;
                while (!success) {
                    const apiKey = getNextApiKey();
                    const baseOptions = {
                        method: 'GET',
                        url: sparkUrl,
                        params: { symbols: symbols.join(","), region: 'US' ,interval:'1d', range:'1mo'},
                        headers: {
                            'x-api-key': apiKey
                        }
                    };

                    try {
                        const response = await axios.request(baseOptions);
                        return response.data;
                    } catch (error) {
                        availableKeys.splice(currentIndex, 1);
                        success = true;
                    }
                }
            }

            const results = [];
            for (let i = 0; i < stocks.length; i += 10) {
                const batch = stocks.slice(i, i + 10);
                const symbols = batch.map(stock => stock.ticker + '.KS');
                const batchData = await fetchBatch(symbols);
                const batchDataSpark = await fetchBatchSpark(symbols);
                batch.forEach((stock, index) => {
                    const data = batchData.find(item => item.symbol === symbols[index]);
                    if (data) {
                        stock.price = data.regularMarketPrice;
                        stock.per = round(stock.price / stock.eps, 2);
                        totalSeed += stock.price*stock.count;
                        totalSeedBefore += stock.price*stock.count;
                        stock.id = data.shortName;
                        const beforeTotal = stock.before1 + stock.before2 + stock.before3 + stock.before4;
                        const afterTotal = stock.after1 + stock.after2 + stock.after3 + stock.after4;
                        stock.growth = round(((afterTotal - beforeTotal) / beforeTotal) * 100, 2);
                        stock.performance = batchDataSpark[symbols[index]].chartPreviousClose;
                    }
                    results.push(stock);
                });
            }
            return results;
        }


        async function init() {
            dataset = await fetchStockData(stocks);

            dataset = dataset.filter(item => item.growth >= item.per && item.per <= 25);

            for (let stock of dataset) {
                stock.targetPrice = stock.price * Math.sqrt(Math.min(stock.growth, 25) / stock.per);
                stock.point = stock.growth * (30 - stock.per);
            }
            const totalPoint = dataset.reduce((sum, stock) => sum + stock.point, 0);

            dataset.forEach(stock => {
                stock.allocation = (stock.point / totalPoint) * 100;
                stock.targetCount = Math.floor((totalSeed * stock.allocation / 100) / stock.price);
            });

            let remains = totalSeed - dataset.reduce((sum, stock) => sum + (stock.targetCount * stock.price), 0);

            while (remains > 0) {
                let bought = false;
                for (let stock of dataset) {
                    if (remains >= stock.price) {
                        stock.targetCount++;
                        remains -= stock.price;
                        bought = true;
                    }
                }
                if (!bought) break;
            }
            // point 값을 기준으로 정렬
            dataset.sort((a, b) => b.point - a.point);
            document.getElementById("addingSeed").innerText = addingSeed.toLocaleString();
            document.getElementById("totalSeed").innerText = totalSeed.toLocaleString();
            
            let targetPriceHtml = "";
            dataset.forEach(stock => {
                targetPriceHtml += `<p>${stock.id}: ${stock.price.toLocaleString()} → ${round(stock.targetPrice, 0).toLocaleString()} (${round((stock.targetPrice - stock.price) / stock.price * 100, 1)}%)</p>`;
            });
            document.getElementById("targetPrice").innerHTML = targetPriceHtml;

            // 매수매도 ui 처리
            let tradeDatas =[];
            let html ='';
            dataset.map((stock,index)=> {
                if((stock.targetCount - stock.count) != 0){
                    tradeDatas[index] = {};
                    tradeDatas[index].id = stock.id;
                    tradeDatas[index].tradeCount = stock.targetCount - stock.count;
                }
            });
            tradeDatas.sort((a, b) => a.tradeCount - b.tradeCount);
            tradeDatas.map((data)=>{
                let tradeText = data.id;
                if(data.tradeCount > 0){
                    html += '<div class="bg-white text-red-500 rounded-lg shadow-md p-4 w-50">';
                    tradeText += ' 매수';
                }else{
                    html += '<div class="bg-white text-blue-500 rounded-lg shadow-md p-4 w-50">';
                    tradeText += ' 매도';
                }
                html +='<h3 class="text-lg font-bold">'+tradeText+'</h3>';
                html +='<p>수량 '+Math.abs(data.tradeCount)+'주</p>';
                html +='</div>';
            });
            document.getElementById("trade").innerHTML = html;

            //월간 성과계산
            let performanceRate;
            let performanceValue=0;
            let performanceRateN;
            let performanceValueN=0;
            dataset.map((stock,i) => {
                performanceValue += (stock.price - stock.performance) * stock.count;
                performanceValueN += (stock.price - stock.performance) * stock.targetCount;
            });
            performanceRate = round(performanceValue / (totalSeedBefore - performanceValue) * 100 , 2);
            performanceRateN = round(performanceValueN / (totalSeed - performanceValueN) * 100 , 2);
            document.getElementById("performanceRate").innerHTML = performanceRate;
            document.getElementById("performanceValue").innerHTML = performanceValue.toLocaleString();
            document.getElementById("performanceRateN").innerHTML = performanceRateN;
            document.getElementById("performanceValueN").innerHTML = performanceValueN.toLocaleString();
            // 랜덤 색상을 생성하는 유틸리티 함수
            function getColorFromValue(value) {
                const clampedValue = Math.max(-20, Math.min(20, value));
                const alpha = Math.abs(clampedValue) / 20;
                const red = clampedValue > 0 ? 255 : 0;
                const blue = clampedValue < 0 ? 255 : 0;
                const green = 0;
                return `rgba(${red}, ${green}, ${blue}, ${alpha})`;
            }
            let ctx1_now = document.getElementById("myChart1_now").getContext("2d");
            const chartdata_now = dataset.map(item => {
                return {
                    id : item.id,
                    percentage: round(item.count * item.price / totalSeed * 100,2),
                    performanceRate:round((item.price - item.performance)/item.performance * 100,2)
                };
            });
            new Chart(ctx1_now, {
                type: 'treemap', // Treemap 타입 사용
                data: {
                    datasets: [{
                        label: '포트폴리오 분배',
                        tree: chartdata_now,
                        key: 'percentage', // 데이터에서 값 키 설정
                        backgroundColor:(ctx1) => {
                            if(ctx1.raw){
                                const value = ctx1.raw._data.performanceRate; // 데이터의 값
                                return getColorFromValue(value); // 색상 반환
                            }
                            
                        },
                        borderColor: 'rgba(0, 0, 0, 0.1)',
                        borderWidth: 1
                    }]
                },
                options: {
                    plugins: {
                        legend: {
                            display: false // 범례 숨김
                        },
                        tooltip: {
                            callbacks: {
                                label: (tooltipItem) => {
                                    const rawData = tooltipItem.raw._data;
                                    return `지난 1개월: ${rawData.performanceRate}%`;
                                }
                            }
                        },
                        datalabels: {
                            color: 'black', // 레이블 텍스트 색상
                            font: {
                                weight: 'bold',
                                size: 14
                            },
                            formatter: (formatterItem) => {
                                const dataItem = formatterItem._data; // 
                                return `${dataItem.id}\n${dataItem.percentage}%`;
                            },
                            align: 'center', // 레이블 텍스트 정렬
                            anchor: 'center' // 레이블 위치
                        }
                    }
                },
                plugins: [ChartDataLabels] // datalabels 플러그인 활성화
            });

            let ctx1_after = document.getElementById("myChart1_after").getContext("2d");
            const chartdata_after = dataset.map(item => {
                return {
                    id : item.id,
                    percentage: round(item.targetCount * item.price / totalSeed * 100,2),
                    performanceRate:round((item.price - item.performance)/item.performance * 100,2)
                };
            });
            new Chart(ctx1_after, {
                type: 'treemap', // Treemap 타입 사용
                data: {
                    datasets: [{
                        label: '포트폴리오 분배',
                        tree: chartdata_after,
                        key: 'percentage', // 데이터에서 값 키 설정
                        backgroundColor:(ctx1) => {
                            if(ctx1.raw){
                                const value = ctx1.raw._data.performanceRate; // 데이터의 값
                                return getColorFromValue(value); // 색상 반환
                            }
                            
                        },
                        borderColor: 'rgba(0, 0, 0, 0.1)',
                        borderWidth: 1
                    }]
                },
                options: {
                    plugins: {
                        legend: {
                            display: false // 범례 숨김
                        },
                        tooltip: {
                            callbacks: {
                                label: (tooltipItem) => {
                                    const rawData = tooltipItem.raw._data;
                                    return `지난 1개월: ${rawData.performanceRate}%`;
                                }
                            }
                        },
                        datalabels: {
                            color: 'black', // 레이블 텍스트 색상
                            font: {
                                weight: 'bold',
                                size: 14
                            },
                            formatter: (formatterItem) => {
                                const dataItem = formatterItem._data; // 
                                return `${dataItem.id}\n${dataItem.percentage}%`;
                            },
                            align: 'center', // 레이블 텍스트 정렬
                            anchor: 'center' // 레이블 위치
                        }
                    }
                },
                plugins: [ChartDataLabels] // datalabels 플러그인 활성화
            });



            // dataset2 초기화 및 데이터 생성 부분
            var targetGrowth = 1.004867;
            var targetSave = 0.03;
            var lastMoney = 1;
            var monthlyInflationRate = 1.0020593; // 월간 인플레이션 0.20593%
            var targetFinalMoney = 8.6; // 현재기준 금액 

            // 월별 인플레이션을 누적 적용하여 각 월에 목표 금액을 조정
            function inflationAdjustedTarget(futureValue, inflationRate, monthsElapsed) {
                return futureValue * Math.pow(inflationRate, monthsElapsed);
            }

            // 현재부터 2040년 12월까지 남은 월 수 계산
            const currentYear = new Date().getFullYear();
            const currentMonth = new Date().getMonth();
            const monthsTo2040 = (2040 - currentYear) * 12 + (11 - currentMonth); // 2040년 12월 기준

            function getMonthlyDatesForYears() {
                const startDate = new Date(2024, 0, 1);
                const endDate = new Date(2040, 11, 1);
                const monthlyDates = [];

                let currentDate = startDate;
                while (currentDate < endDate) {
                    monthlyDates.push(new Date(currentDate));
                    currentDate.setMonth(currentDate.getMonth() + 1);
                }

                return monthlyDates;
            }

            const dates = getMonthlyDatesForYears();
            dates.forEach((date, i) => {
                dataset2.push({
                    date: date.toLocaleDateString('ko-KR', { year: 'numeric', month: 'long' }),
                    targetMoney: lastMoney * targetGrowth + targetSave,
                    inflationAdjustedTarget: inflationAdjustedTarget(targetFinalMoney, monthlyInflationRate, i)
                });
                lastMoney = dataset2[i].targetMoney;
            });

            for (let i = 0; i < moneyCurveDatas.length; i++) {
                dataset2[i].currentMoney = moneyCurveDatas[i];
            }
            //목표달성률 (현재)
            const lastData = dataset2[moneyCurveDatas.length-1];
            const lastBeforeData = dataset2[moneyCurveDatas.length-2];
            const goalAchievementRate = lastData.currentMoney / lastData.inflationAdjustedTarget * 100;
            const goalAchievementBeforeRate = lastBeforeData.currentMoney / lastBeforeData.inflationAdjustedTarget * 100;
            document.getElementById("goalAchievementRate").innerText = Math.round(goalAchievementBeforeRate * 10) / 10 + "% =>"+Math.round(goalAchievementRate * 10) / 10 + "%";
            //기준대비 달성률(현재)
            const goalOverPerformRate = (lastData.currentMoney - lastData.targetMoney)/ lastData.targetMoney * 100;
            document.getElementById("goalOverPerformRate").innerText = Math.round(goalOverPerformRate * 10) / 10;
            // Chart.js를 사용하여 두 번째 그래프 그리기
            let ctx2 = document.getElementById('myChart2').getContext('2d');
            myChart2 = new Chart(ctx2, {
                type: 'line',
                data: {
                    labels: dataset2.map(data => data.date),
                    datasets: [
                        {
                            label: '목표 금액',
                            data: dataset2.map(data => data.targetMoney),
                            borderColor: 'rgba(75, 192, 192, 1)',
                            backgroundColor: 'rgba(75, 192, 192, 0.2)',
                            fill: true,
                            tension: 0.1
                        },
                        {
                            label: '현재 금액',
                            data: dataset2.map(data => data.currentMoney),
                            borderColor: 'rgba(255, 99, 132, 1)',
                            backgroundColor: 'rgba(255, 99, 132, 0.2)',
                            fill: true,
                            tension: 0.1
                        },
                        {
                            label: '인플레이션 감안 목표 금액',
                            data: dataset2.map(data => data.inflationAdjustedTarget),
                            borderColor: 'rgba(54, 162, 235, 1)',
                            backgroundColor: 'rgba(54, 162, 235, 0.2)',
                            fill: true,
                            tension: 0.1,
                            borderDash: [10, 5]
                        }
                    ]
                },
                options: {
                    responsive: true,
                    scales: {
                        y: {
                            beginAtZero: false,
                            title: {
                                display: true,
                                text: '금액 (단위: 억)'
                            }
                        }
                    },
                    plugins: {
                        title: {
                            display: true,
                            text: '목표달성률 트래킹 및 인플레이션 감안 목표선'
                        },
                        tooltip: {
                            callbacks: {
                                label: function(context) {
                                    return `${context.dataset.label}: ${context.parsed.y.toFixed(4)}`;
                                }
                            }
                        }
                    }
                }
            });
        }

        function round(value, decimals) {
            return Number(Math.round(value + "e" + decimals) + "e-" + decimals);
        }
        // 차트 데이터를 업데이트하는 함수
        async function updateChart() {
            // 입력된 시작 및 종료 날짜 가져오기
            const startDate = new Date(document.getElementById("startDate").value);
            startDate.setHours(0, 0, 0, 0);
            const endDateInput = document.getElementById("endDate").value.split("-");
            const endYear = parseInt(endDateInput[0]);
            const endMonth = parseInt(endDateInput[1]);
            const endDate = new Date(endYear, endMonth, 0);
            endDate.setHours(0, 0, 0, 0);

            // 선택된 기간에 맞게 dataset2 데이터 필터링
            const filteredData = dataset2.filter(data => {
                const [year, month] = data.date.split('년 ');
                const formattedDate = new Date(parseInt(year), parseInt(month.replace('월', '').trim()) - 1, 1);
                formattedDate.setHours(0, 0, 0, 0);
                return formattedDate.getTime() >= startDate.getTime() && formattedDate.getTime() <= endDate.getTime();
            });

            // 필터링된 데이터로 차트 업데이트
            myChart2.data.labels = filteredData.map(data => data.date);
            myChart2.data.datasets[0].data = filteredData.map(data => data.targetMoney);
            myChart2.data.datasets[1].data = filteredData.map(data => data.currentMoney);
            myChart2.data.datasets[2].data = filteredData.map(data => data.inflationAdjustedTarget);

            myChart2.update(); // 차트 업데이트
        }
        preQuery();
    </script>
</body>
</html>